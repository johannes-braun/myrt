#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) uniform sampler2D input_image;
layout(binding = 1, rgba16f) uniform writeonly image2D output_image;

const float kernel[] = {
  0.08756118061424645,
  0.08547984344465417,
  0.07952880794840879,
  0.0705164133185798,
  0.05958841266910679,
  0.04798885898065629,
  0.03683205838316095,
  0.0269412473017388,
  0.018780823225920923,
  0.012477173150624141,
  0.007899915153736418,
  0.004766876346593609,
  0.0027412691146821303,
  0.001502371210393176,
  0.0007847156649807812,
  0.0003906237796399568
};
const int kernel_radius = 15;

uniform int direction;
uniform float step;

void main()
{
  uvec2 pt = gl_GlobalInvocationID.xy;
  uvec2 image_size = uvec2(textureSize(input_image, 0));
  uint id = pt.y * image_size.x + pt.x;
  if(pt.x > image_size.x || pt.y > image_size.y)
  {
    return;
  }
  vec2 pixel = vec2(pt);
  vec2 iimage_size = vec2(1.0) / image_size;
  vec4 result = kernel[0] * textureLod(input_image, pixel * iimage_size, 0);
  int dir = int(bool(direction));
  vec2 pixel_step = vec2(1-dir, dir) * step;
  for(int i=1; i < kernel_radius+1; ++i)
  {
    result += kernel[i] * (
      textureLod(input_image, (pixel + i * pixel_step) * iimage_size, 0) + 
      textureLod(input_image, (pixel - i * pixel_step) * iimage_size, 0)
    );
  }

  imageStore(output_image, ivec2(pt), result);
}