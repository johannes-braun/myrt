#version 460 core
#extension GL_ARB_bindless_texture : require
#extension GL_NV_gpu_shader5 : require

layout(local_size_x = 64) in;
layout(bindless_sampler) uniform;

#include "resample.glsl"
#include "transform.glsl"
#include "random.glsl"
//#include "pbr.glsl"

struct generate_output_t {
  vec3  origin;
  float random_value;
  vec3  direction;
  float pixel_x;
  vec3  reflectance;
  float pixel_y;
  vec4  color;
  float pdf;
  float pad[3];
};

struct trace_output_t {
  vec3 point;
  int intersects;
  vec3 normal;
  uint generated_ray;

  vec2 uv;
  int material_index;
  
  uint light_color;
  vec3 light_direction;
  float light_strength;
};

struct material_reference_t
{
  int id;
  int offset;
};

layout(binding = 0, std430) restrict buffer GenerateInput { generate_output_t generate_output[]; };
layout(binding = 1, std430) restrict readonly buffer TraceOutput { trace_output_t trace_output[]; };
layout(binding = 2, std430) readonly buffer AccessControl { 
  uint num_elements;
  uint num_groups_x;
  uint num_groups_y;
  uint num_groups_z;
};
layout(binding = 3, std430) restrict readonly buffer MaterialsBuffer { material_reference_t materials[]; };
layout(binding = 4, std430) restrict readonly buffer MaterialsDataBuffer { float materials_data[]; };

layout(binding = 0, rgba32f) uniform image2D debug_image;
layout(binding = 1, rgba32f) uniform image2D output_image;
layout(binding = 0) uniform sampler1D random_texture;
layout(binding = 1) uniform samplerCube cubemap;

layout(location = 0) uniform uint sample_index;
layout(location = 1) uniform bool force_write_color;
layout(location = 2) uniform int random_sample;
layout(location = 3) uniform int bounce_index;
vec3 tonemapFilmic(vec3 x) {
  vec3 X = max(vec3(0.0), x - 0.004);
  vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
  return pow(result, vec3(2.2));
}

float tonemapFilmic(float x) {
  float X = max(0.0, x - 0.004);
  float result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
  return pow(result, 2.2);
}

vec3 unreal(vec3 x) {
  return x / (x + 0.155) * 1.019;
}

float unreal(float x) {
  return x / (x + 0.155) * 1.019;
}

vec3 tonemap(vec3 col)
{
  return tonemapFilmic(col);
}

vec4 rescale_rgb(vec4 col)
{
  return vec4(pow(col.rgb, vec3(1/1.0)), col.a);
} 

vec4 unscale_rgb(vec4 col)
{
  return vec4(pow(col.rgb, vec3(1.0)), col.a);
}

void accumulate_color(vec4 new_colori, ivec2 pixel)
{
  generate_output_t gen = generate_output[gl_GlobalInvocationID.x];
  vec4 new_color = clamp(new_colori, 0, 20);

  vec4 last_color = imageLoad(debug_image, pixel);

  if(any(isnan(new_color))||any(isinf(new_color)))
  {
    new_color = last_color;
  }

  if(sample_index == 0)
  {
    last_color = new_color;
  }
  else
  {
    vec4 nc = new_color;
    last_color = mix(last_color, nc, 1.0 / float(sample_index + 1));
  }
  imageStore(debug_image, pixel, last_color);
  imageStore(output_image, pixel, vec4(tonemap(last_color.rgb), last_color.a));
}

struct material_sample_t
{
  vec4 color;
  vec3 reflectance;
  float pdf;
};

#define _G(P) materials_data[P]
#define _MTY(I) materials[I].id
#define _MBO(I) materials[I].offset
#include "material.glsl"
#undef _G
#undef _MTY
#undef _MBO

void main() {
  uint id = gl_GlobalInvocationID.x;
  if(id >= num_elements)
  {
    return;
  }

  trace_output_t trace = trace_output[id];
  generate_output_t gen = generate_output[id];
  
  ivec2 pixel = ivec2(gen.pixel_x, gen.pixel_y);
  if(trace.intersects != 0)
  {
    if(trace.intersects == 2) // hit light
    {
      trace.intersects = 0;
      if(bounce_index == 0)
        accumulate_color(vec4((unpackUnorm4x8(trace.light_color).rgb * trace.light_strength), 1), ivec2(pixel));
      else
        accumulate_color(vec4((unpackUnorm4x8(trace.light_color).rgb * trace.light_strength * gen.reflectance + gen.color.rgb), 1), ivec2(pixel));
      return;
    }

    random_init(random_texture, pixel, random_sample);
    float rx = random_value(int(int(56128966 * gen.random_value) + 20945293*id));
    float ry = random_value(int(int(12233432 * gen.random_value) + 74867839*id));
    
    material_load(trace.material_index);

    vec2 material_randoms = vec2(random_next(), random_next());
    vec3 generated = material_continue_ray(material_randoms, -gen.direction, trace.normal);

    material_sample_t material;
    material_sample(trace.point, trace.uv, trace.normal, generated, -gen.direction, material.reflectance, material.pdf);

    if(force_write_color || material.pdf < 1e-6 || isnan(material.pdf) || isinf(material.pdf) || 
      any(isnan(material.reflectance)) || any(isinf(material.reflectance)) || 
      any(isnan(generated)) || any(isinf(generated)))
    {
      if(any(isnan(material.reflectance)) || any(isinf(material.reflectance)))
        accumulate_color(gen.color, ivec2(pixel));
      else
        accumulate_color(gen.color + vec4(gen.reflectance, 0), ivec2(pixel));
      return;
    }
    
    if(trace.light_strength > 0)
    {
      material_sample_t light_material;
      material_sample(trace.point, trace.uv, trace.normal, trace.light_direction, -gen.direction, light_material.reflectance, light_material.pdf);
      
      gen.color += vec4(unpackUnorm4x8(trace.light_color).rgb * trace.light_strength * light_material.reflectance * gen.reflectance, 0);
    }

//    {
//      float bias = 3;
//      // trace a ray roughly towards the light...
//      vec3 light_caster = generated;
//      light_caster = normalize(light_caster);
//      
//      material_sample_t light_material2;
//      material_sample(trace.point, trace.uv, trace.normal, light_caster, -gen.direction, light_material2.reflectance, light_material2.pdf);
//
//      if(light_material2.pdf > 5*random_next())
//      {
//        generated = light_caster;
//        float p = material.pdf;
//        material = light_material2;
//        material.pdf = light_material2.pdf;
//      }
//    }

    vec3 ld = -gen.direction;
    vec3 hd = trace.normal;
    gen.direction = generated;
    
    gen.origin = trace.point + 1e-3 * gen.direction;
    gen.pdf *= material.pdf;
    gen.reflectance *= material.reflectance * abs(dot(generated, hd)) / material.pdf;
    gen.random_value = random_value(int(int(2341335623 * gen.random_value) + 357883444*id));
    generate_output[id] = gen;
  }
  else
  { 
    vec3 env;
    if(textureSize(cubemap, 0).x > 10)
    {
      env = gen.reflectance * textureLod(cubemap, gen.direction, 0).rgb;
    }
    else
    {
      env = gen.reflectance * mix(vec3(0.3, 0.4, 0.5), vec3(1.0, 0.98, 0.96), (gen.direction.y + 1) / 2);
    }
    accumulate_color(gen.color + vec4(env, 0), ivec2(pixel));
  }
}