#version 460 core

layout(local_size_x = 64) in;

#include "resample.glsl"
#include "transform.glsl"
#include "random.glsl"
#include "pbr.glsl"

struct generate_output_t {
  vec3  origin;
  float random_value;
  vec3  direction;
  float pixel_x;
  vec3  reflectance;
  float pixel_y;
  vec4  color;
  float pdf;
  float pad[3];
};

struct trace_output_t {
  vec3 point;
  int intersects;
  vec3 normal;
  uint generated_ray;

  vec2 uv;
  int material_index;
  int _p0;
  
  vec3 light_direction;
  int _p1;
  vec3 light_contribution;
  int _p2;
};

layout(binding = 2, std430) readonly buffer AccessControl { 
  uint num_elements;
  uint num_groups_x;
  uint num_groups_y;
  uint num_groups_z;
};

layout(binding = 0, std430) restrict buffer GenerateInput { generate_output_t generate_output[]; };
layout(binding = 1, std430) restrict readonly buffer TraceOutput { trace_output_t trace_output[]; };

layout(binding = 0, rgba32f) uniform image2D debug_image;
layout(binding = 1, rgba32f) uniform image2D output_image;
layout(binding = 0) uniform sampler1D random_texture;
layout(binding = 1) uniform samplerCube cubemap;

layout(location = 0) uniform uint sample_index;
layout(location = 1) uniform bool force_write_color;
layout(location = 2) uniform int random_sample;

vec3 unreal(vec3 x) {
  return x / (x + 0.155) * 1.019;
}

float unreal(float x) {
  return x / (x + 0.155) * 1.019;
}
vec3 tonemap(vec3 col)
{
  col = clamp(col, 0, 10);
  return unreal(col);
}

void accumulate_color(vec4 new_color, ivec2 pixel)
{
  new_color.rgb = tonemap(new_color.rgb);

  vec4 last_color = imageLoad(output_image, pixel);
  vec4 comparison = last_color;
  if(sample_index == 0)
  {
    last_color = new_color;
    comparison = vec4(1);
  }
  else
  {
    last_color = mix(last_color, new_color, 1.0 / float(sample_index + 1));
    comparison = vec4(abs(last_color - comparison));
  }
  imageStore(debug_image, pixel, comparison);
  imageStore(output_image, pixel, last_color);
}

struct material_sample_t
{
  vec4 color;
  vec3 reflectance;
  float pdf;
};

void mix_onto(inout material_sample_t dst, material_sample_t other, float weight)
{
  dst.color = mix(dst.color, other.color, weight);
  dst.reflectance = mix(dst.reflectance, other.reflectance, weight);
  dst.pdf = mix(dst.pdf, other.pdf, weight);
}

material_info_t get_test_material(int index) {
  float met = 0.0;
  float tm = 0.0;
  vec3 diff = vec3(1);
  switch(index)
  {
    case 0: diff = vec3(1, 0, 0.3); met = 1; break;
    case 1: diff = vec3(0, 1, 0.3); tm = 1.0; break;
    case 2: diff = vec3(0.4, 0.1, 0.5); break;
    case 3: diff = vec3(0.3, 0.4,0.0); tm = 1.0; break;
    case 4: diff = vec3(1,1, 1.0); met = 1; break;
  };

  material_info_t m;
  m.roughness = 0.2;
  m.albedo_rgba_unorm = color_make(vec4(diff, 1));
  m.ior = 1.5;
  m.metallic = met;
  m.transmission = tm;
  return m;
}

vec3 material_continue_ray(trace_output_t trace, vec2 random, vec3 towards_viewer, vec3 normal, float ior1, float ior2)
{
  return pbr_resample(random, get_test_material(trace.material_index), towards_viewer, normal, ior1, ior2);
}

material_sample_t sample_material_proto(int index, vec2 uv, vec3 normal, vec3 point, vec3 towards_light, vec3 towards_viewer, float ior1, float ior2)
{
  brdf_result_t ev;
  pbr_eval(get_test_material(index), towards_viewer, towards_light, normal, ior1, ior2, ev);
    
  material_sample_t mat;
  mat.reflectance = ev.reflectance;
  mat.pdf = ev.pdf;
  return mat;
}

struct light_t
{
    vec3 position;
    float radius;
    vec3 color;
    vec2 attenuation;
} test_lights[2];

void material_sample(trace_output_t trace, vec3 towards_light, vec3 towards_viewer, float ior1, float ior2, out material_sample_t material)
{
  material = sample_material_proto(trace.material_index, trace.uv,
    trace.normal, trace.point, towards_light, towards_viewer, ior1, ior2);
}

void main() {
  uint id = gl_GlobalInvocationID.x;
  if(id >= num_elements)
  {
    return;
  }

  test_lights[0].position = vec3(4, 5, 4);
  test_lights[0].color = 25*vec3(1, 1.8, 3);
  test_lights[0].radius = 0.2f;
  test_lights[1].position = vec3(-4, 3, 5);
  test_lights[1].color = 12*vec3(3, 1.8, 1);
  test_lights[1].radius = 0.1f;

  trace_output_t trace = trace_output[id];
  generate_output_t gen = generate_output[id];
  
  ivec2 pixel = ivec2(gen.pixel_x, gen.pixel_y);
  if(trace.intersects != 0)
  {
    random_init(random_texture, pixel, random_sample);
    float rx = random_value(int(int(56128966 * gen.random_value) + 20945293*id));
    float ry = random_value(int(int(12233432 * gen.random_value) + 74867839*id));
    
    bool is_incoming = dot(trace.normal, gen.direction) < 0;
    trace.normal = is_incoming ? trace.normal : -trace.normal;
    float ior_front = is_incoming ? 1.0 : 1.5;
    float ior_back = is_incoming ? 1.5 : 1.0;

    vec2 material_randoms = vec2(random_next(), random_next());
    vec3 generated = material_continue_ray(trace, material_randoms, -gen.direction, trace.normal, ior_front, ior_back);

    material_sample_t material;
    material_sample(trace, generated, -gen.direction, ior_front, ior_back, material);

    if(force_write_color || material.pdf < 1e-3 || isnan(material.pdf) || isinf(material.pdf) || 
      any(isnan(material.reflectance)) || any(isinf(material.reflectance)) || 
      any(isnan(generated)) || any(isinf(generated)))
    {
      if(any(isnan(material.reflectance)) || any(isinf(material.reflectance)))
        accumulate_color(gen.color, ivec2(pixel));
      else
        accumulate_color(gen.color + vec4(material.reflectance * gen.reflectance, 0), ivec2(pixel));
      return;
    }

    if(trace.light_contribution != vec3(0))
    {
      material_sample_t light_material;
      material_sample(trace, trace.light_direction, -gen.direction, ior_front, ior_back, light_material);
      gen.color += vec4(trace.light_contribution * light_material.reflectance, 0);
    }

    gen.pdf *= material.pdf;
    gen.reflectance *= material.reflectance * abs(dot(generated, trace.normal)) / material.pdf;
    gen.direction = generated;
    gen.origin = trace.point + 1e-3 * gen.direction;
    gen.random_value = random_value(int(int(2341335623 * gen.random_value) + 357883444*id));
    generate_output[id] = gen;
  }
  else
  { 
    vec3 env;
    if(textureSize(cubemap, 0).x > 10)
    {
      env = gen.reflectance * textureLod(cubemap, gen.direction, 0).rgb;
    }
    else
    {
      env = gen.reflectance * mix(vec3(0.3, 0.4, 0.5), vec3(1.0, 0.98, 0.96), (gen.direction.y + 1) / 2);
    }
    accumulate_color(gen.color + vec4(env, 0), ivec2(pixel));
  }
}