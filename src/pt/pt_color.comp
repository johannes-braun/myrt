#version 460 core

layout(local_size_x = 64) in;

#include "resample.glsl"
#include "transform.glsl"
#include "random.glsl"
#include "pbr.glsl"

struct generate_output_t {
  vec3  origin;
  float random_value;
  vec3  direction;
  float pixel_x;
  vec3  reflectance;
  float pixel_y;
  vec4  color;
  float pdf;
  float pad[3];
};

struct trace_output_t {
  vec3 point;
  int intersects;
  vec3 normal;
  uint generated_ray;

  vec2 uv;
  int material_index;
  
  uint light_color;
  vec3 light_direction;
  float light_strength;
};

layout(binding = 2, std430) readonly buffer AccessControl { 
  uint num_elements;
  uint num_groups_x;
  uint num_groups_y;
  uint num_groups_z;
};

layout(binding = 0, std430) restrict buffer GenerateInput { generate_output_t generate_output[]; };
layout(binding = 1, std430) restrict readonly buffer TraceOutput { trace_output_t trace_output[]; };

layout(binding = 0, rgba32f) uniform image2D debug_image;
layout(binding = 1, rgba32f) uniform image2D output_image;
layout(binding = 0) uniform sampler1D random_texture;
layout(binding = 1) uniform samplerCube cubemap;

layout(location = 0) uniform uint sample_index;
layout(location = 1) uniform bool force_write_color;
layout(location = 2) uniform int random_sample;
layout(location = 3) uniform int bounce_index;
vec3 tonemapFilmic(vec3 x) {
  vec3 X = max(vec3(0.0), x - 0.004);
  vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
  return pow(result, vec3(2.2));
}

float tonemapFilmic(float x) {
  float X = max(0.0, x - 0.004);
  float result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);
  return pow(result, 2.2);
}

vec3 unreal(vec3 x) {
  return x / (x + 0.155) * 1.019;
}

float unreal(float x) {
  return x / (x + 0.155) * 1.019;
}

bool li = false;
vec3 tonemap(vec3 col)
{
  col = li ? col : clamp(col, 0, 30);
  return tonemapFilmic(col);
}

void accumulate_color(vec4 new_colori, ivec2 pixel)
{
  vec4 new_color = vec4(tonemap(new_colori.rgb).rgb, new_colori.w);

  vec4 lic = imageLoad(debug_image, pixel);
  vec4 last_color = imageLoad(output_image, pixel) - lic;
  vec4 comparison = last_color;
  if(sample_index == 0)
  {
    if(li)
      lic = 10*new_colori;
    else
      lic = vec4(0);
    last_color = new_color;
  }
  else
  {
    if(li)
      lic = mix(lic, 10*new_color, 1.0 / float(sample_index + 1));
    else
      lic = mix(lic, vec4(0), 1.0 / float(sample_index + 1));
    last_color = mix(last_color, new_color, 1.0 / float(sample_index + 1));
  }
  imageStore(debug_image, pixel, lic);
  imageStore(output_image, pixel, last_color + lic);
}

struct material_sample_t
{
  vec4 color;
  vec3 reflectance;
  float pdf;
};

material_info_t get_test_material(int index) {
  float met = 0.0;
  float tm = 0.0;
  vec3 diff = vec3(1);
  switch(index)
  {
    case 0: diff = vec3(1, 0, 0.3); break;
    case 1: diff = vec3(0, 1, 0.3); tm = 2.0; break;
    case 2: diff = vec3(0.4, 0.1, 0.5); break;
    case 3: diff = vec3(0.3, 0.4,0.0); tm = 1.0; break;
    case 4: diff = vec3(0.5); tm = 1; break;
  };

  material_info_t m;
  m.roughness = 0.1;
  m.albedo_rgba_unorm = color_make(vec4(diff, 1));
  m.ior = 1.5;
  m.metallic = met;
  m.transmission = tm;
  return m;
}

vec3 material_continue_ray(trace_output_t trace, vec2 random, vec3 towards_viewer, vec3 normal, float ior1, float ior2)
{
  return pbr_resample(random, get_test_material(trace.material_index), towards_viewer, normal, ior1, ior2);
}

material_sample_t sample_material_proto(int index, vec2 uv, vec3 normal, vec3 point, vec3 towards_light, vec3 towards_viewer, float ior1, float ior2)
{
  brdf_result_t ev;
  pbr_eval(get_test_material(index), towards_viewer, towards_light, normal, ior1, ior2, ev);
    
  material_sample_t mat;
  mat.reflectance = ev.reflectance;
  mat.pdf = ev.pdf;
  return mat;
}

void material_sample(trace_output_t trace, vec3 towards_light, vec3 towards_viewer, float ior1, float ior2, out material_sample_t material)
{
  material = sample_material_proto(trace.material_index, trace.uv,
    trace.normal, trace.point, towards_light, towards_viewer, ior1, ior2);
}

void main() {
  uint id = gl_GlobalInvocationID.x;
  if(id >= num_elements)
  {
    return;
  }

  trace_output_t trace = trace_output[id];
  generate_output_t gen = generate_output[id];
  
  ivec2 pixel = ivec2(gen.pixel_x, gen.pixel_y);
  if(trace.intersects != 0)
  {
    if(trace.intersects == 2) // hit light
    {
      li = true;
      accumulate_color(vec4(unpackUnorm4x8(trace.light_color).rgb * trace.light_strength * gen.reflectance, 0) + gen.color, ivec2(pixel));
      return;
    }

    random_init(random_texture, pixel, random_sample);
    float rx = random_value(int(int(56128966 * gen.random_value) + 20945293*id));
    float ry = random_value(int(int(12233432 * gen.random_value) + 74867839*id));
    
    bool is_incoming = dot(trace.normal, gen.direction) < 0;
    trace.normal = is_incoming ? trace.normal : -trace.normal;

    float ior_front = is_incoming ? 1.0 : 1.5;
    float ior_back = is_incoming ? 1.5 : 1.0;

    vec2 material_randoms = vec2(random_next(), random_next());
    vec3 generated = material_continue_ray(trace, material_randoms, -gen.direction, trace.normal, ior_front, ior_back);

    material_sample_t material;
    material_sample(trace, generated, -gen.direction, ior_front, ior_back, material);

    if(force_write_color || material.pdf < 1e-3 || isnan(material.pdf) || isinf(material.pdf) || 
      any(isnan(material.reflectance)) || any(isinf(material.reflectance)) || 
      any(isnan(generated)) || any(isinf(generated)))
    {
      if(any(isnan(material.reflectance)) || any(isinf(material.reflectance)))
        accumulate_color(gen.color, ivec2(pixel));
      else
        accumulate_color(gen.color + vec4(material.reflectance * gen.reflectance, 0), ivec2(pixel));
      return;
    }

    if(trace.light_strength > 0)
    {
      material_sample_t light_material;
      material_sample(trace, trace.light_direction, -gen.direction, ior_front, ior_back, light_material);
      
      gen.color += vec4(unpackUnorm4x8(trace.light_color).rgb * trace.light_strength * light_material.reflectance * gen.reflectance, 0);
    }

    gen.pdf *= material.pdf;
    gen.reflectance *= material.reflectance * abs(dot(generated, trace.normal)) / material.pdf;
    gen.direction = generated;
    gen.origin = trace.point + 1e-3 * gen.direction;
    gen.random_value = random_value(int(int(2341335623 * gen.random_value) + 357883444*id));
    generate_output[id] = gen;
  }
  else
  { 
    vec3 env;
    if(textureSize(cubemap, 0).x > 10)
    {
      env = gen.reflectance * textureLod(cubemap, gen.direction, 0).rgb;
    }
    else
    {
      env = gen.reflectance * mix(vec3(0.3, 0.4, 0.5), vec3(1.0, 0.98, 0.96), (gen.direction.y + 1) / 2);
    }
    accumulate_color(gen.color + vec4(env, 0), ivec2(pixel));
  }
}