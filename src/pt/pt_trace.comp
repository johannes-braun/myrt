#version 460 core
#extension GL_ARB_gpu_shader_int64: require

const int group_size = 64;
layout(local_size_x = group_size) in;

struct generate_output_t {
  vec3  origin;
  float random_value;
  vec3  direction;
  float pixel_x;
  vec3  reflectance;
  float pixel_y;
  vec4  color;
  float pdf;
  float weight;
  float pad[2];
};

struct trace_output_t {
  vec3 point;
  int intersects;
  vec3 normal;
  uint generated_ray;

  vec2 uv;
  int material_index;
  
  uint light_color;
  vec3 light_direction;
  float light_strength;
};

struct drawable_geometry_t
{
    mat4 transformation;
    mat4 inverse_transformation;
    uint bvh_node_base_index;
    uint bvh_index_base_index;
    uint indices_base_index;
    uint points_base_index;
    uint index_count;

    int material_index;
    int geometry_index;
    int pad[1];
};

struct drawable_sdf_t {
  mat4 transformation;
  mat4 inverse_transformation;
  int sdf_index;
  int pad[3];
};

struct hit_t
{
  vec3 position;
  float t;
  vec3 normal;
  vec2 uv;
  bool hits;
  int material_index;

  int hits_light;
};

#include "intersect.glsl"
#include "bvh.glsl"

layout(binding = 0, std430) restrict readonly buffer GenerateInput { generate_output_t generate_output[]; };
layout(binding = 1, std430) restrict writeonly buffer TraceOutput { trace_output_t trace_output[]; };
layout(binding = 2, std430) restrict buffer AccessControl { 
  uint num_elements;
  uint num_groups_x;
  uint num_groups_y;
  uint num_groups_z;
};

layout(binding = 3, std430) restrict readonly buffer SDFDrawables { drawable_sdf_t sdf_drawables[]; };
layout(binding = 4, std430) restrict readonly buffer SDFData { float sdf_buffer[]; };
layout(binding = 5, std430) restrict readonly buffer BVH { MYRT_BVH_NODE_STRUCT bvh_nodes[]; };
layout(binding = 6, std430) restrict readonly buffer BVHIndices { uint bvh_indices[]; };
layout(binding = 7, std430) restrict readonly buffer MeshIndices { uint indices[]; };
layout(binding = 8, std430) restrict readonly buffer MeshPoints { vec4 points[]; };
layout(binding = 9, std430) restrict readonly buffer MeshNormals { vec4 normals[]; };
layout(binding = 13, std430) restrict readonly buffer MeshUVs { vec2 uvs[]; };
layout(binding = 10, std430) restrict readonly buffer Geometries { drawable_geometry_t geometries[]; };
layout(binding = 11, std430) restrict readonly buffer BVHGlobal { MYRT_BVH_NODE_STRUCT global_bvh_nodes[]; };
layout(binding = 12, std430) restrict readonly buffer BVHIndicesGlobal { uint global_bvh_indices[]; };

layout(binding = 0) uniform sampler1D random_texture;

layout(location = 0) uniform int sdf_marching_steps;
layout(location = 1) uniform float sdf_marching_epsilon;
layout(location = 2) uniform int random_sample;

#define MYRT_BVH_NODES_BUFFER bvh_nodes
#define MYRT_BVH_INDICES_BUFFER bvh_indices
#define MYRT_BVH_TRAVERSE bvh_traverse
#define MYRT_BVH_VISIT_PRIMITIVE visit_triangle
#include "bvh.impl.glsl"
#undef MYRT_BVH_VISIT_PRIMITIVE
#undef MYRT_BVH_TRAVERSE
#undef MYRT_BVH_INDICES_BUFFER
#undef MYRT_BVH_NODES_BUFFER

#define MYRT_BVH_NODES_BUFFER global_bvh_nodes
#define MYRT_BVH_INDICES_BUFFER global_bvh_indices
#define MYRT_BVH_TRAVERSE bvh_traverse_global
#define MYRT_BVH_VISIT_PRIMITIVE visit_object_aabb
#include "bvh.impl.glsl"
#undef MYRT_BVH_VISIT_PRIMITIVE
#undef MYRT_BVH_TRAVERSE
#undef MYRT_BVH_INDICES_BUFFER
#undef MYRT_BVH_NODES_BUFFER

#include "raymarch.glsl"

bool any_hit(vec3 ray_origin, vec3 ray_direction, float max_distance);
hit_t nearest_hit(vec3 ray_origin, vec3 ray_direction, float max_distance);

struct light_t
{
  vec3 position;
  float radius;
  vec3 color;
  vec2 attenuation;
} test_lights[2];

int light_index = 0;
vec3 point_on_light;

void main() {
  uint id = gl_GlobalInvocationID.x;
  if(id >= num_elements)
  {
    return;
  }

  test_lights[0].position = 2*vec3(4, 5, 4);
  test_lights[0].color = 6*vec3(1, 1.8, 3);
  test_lights[0].radius = 1.5f;
  test_lights[1].position = 2*vec3(-4, 3, 5);
  test_lights[1].color = 8*vec3(3, 1.8, 1);
  test_lights[1].radius = 1.5f;

  generate_output_t base = generate_output[id];
  
  random_init(random_texture, ivec2(base.pixel_x, base.pixel_y), random_sample);
  
  trace_output_t result;
  result.uv = vec2(0);
  result.material_index = 0;
  result.generated_ray = id;
  const float tmax = 1.0 / 0.0;
  float t = tmax;
  
  light_index = clamp(int(test_lights.length() * random_next()), 0, test_lights.length()-1);
  point_on_light = test_lights[light_index].position + normalize(vec3(random_next(), random_next(), random_next())) * test_lights[light_index].radius * sqrt(random_next());
    
  hit_t hit = nearest_hit(base.origin, base.direction, 1.0 / 0.0);
  bool no_hit = !hit.hits;
  for(int l = DONT_OPTIMIZE_ZERO; l < test_lights.length(); ++l)
  {
      float t_light = intersect_sphere(base.origin, base.direction, test_lights[l].position, test_lights[l].radius);
      if(t_light > 0 && (!hit.hits||t_light < hit.t))
      {
        hit.hits = true;
        hit.t = t_light;
        hit.hits_light = l;
      }
  }

  result.light_direction = vec3(0);
  result.light_color = 0;
  result.light_strength = 0;
  if(hit.hits)
  {
    result.intersects = 1;
    result.point = hit.position;
    result.normal = hit.normal;
    result.uv = hit.uv;
    result.material_index = hit.material_index;

    if(any(isinf(result.normal)) || any(isnan(result.normal)))
    {
      result.intersects = 0;
    }
    
    vec3 path_to_light = point_on_light - hit.position;
    vec3 direction_to_light = normalize(path_to_light);
    float distance_to_light = length(path_to_light);
    vec3 lnorm = faceforward(hit.normal, base.direction, hit.normal);

    if(hit.hits_light >= 0)
    {
      point_on_light = base.origin + hit.t * base.direction;
      distance_to_light = distance(base.origin, point_on_light);
      result.intersects = 2;
      vec3 col = test_lights[hit.hits_light].color;
      result.light_strength = length(col);
      result.light_color = packUnorm4x8(vec4(col, 0) / result.light_strength);
      result.light_direction = direction_to_light;
    }
    else if(dot(direction_to_light, lnorm) > 0 && !any_hit(hit.position + lnorm * 0.01, direction_to_light, distance_to_light))
    {
        vec3 ref = test_lights[light_index].color;
        vec3 color = ref;
        result.light_strength = length(color);
        result.light_color = packUnorm4x8(vec4(color, 0) / result.light_strength);
        result.light_strength *= test_lights.length()/ (distance_to_light);
        result.light_direction = direction_to_light;
    }

    result.generated_ray = id;
  }
  else
  {
    result.intersects = 0;
    result.point = vec3(0);
    result.normal = vec3(0);
  }

  trace_output[id] = result;
}


struct traversal_state_t
{
    bool any_hit;
    float t;
    float global_t;
    vec2 barycentric;
    vec2 global_barycentric;
    uint hit_geometry;
    uint hit_index;
    uint global_hit_index;

    uint base_index;
    uint base_vertex;
    uint current_geometry;
} traversal;

void traversal_init() {
    const float inf = 1.0 / 0.0;
    traversal.any_hit = false;
    traversal.t = inf;
    traversal.global_t = inf;
    traversal.barycentric = vec2(0, 0);
    traversal.global_barycentric = vec2(0, 0);
    traversal.hit_geometry = 0;
    traversal.hit_index = 0;
    traversal.global_hit_index = 0;
    traversal.base_index = 0;
    traversal.base_vertex = 0;
}

bool visit_triangle(vec3 ray_origin, vec3 ray_direction, uint index, inout float max_ray_distance, out bool hits)
{
    vec3 p0 = points[traversal.base_vertex + indices[traversal.base_index + index * 3 + 0]].xyz;
    vec3 p1 = points[traversal.base_vertex + indices[traversal.base_index + index * 3 + 1]].xyz;
    vec3 p2 = points[traversal.base_vertex + indices[traversal.base_index + index * 3 + 2]].xyz;

    float t_current = 0;
    vec2 barycentric_current = vec2(0, 0);
    hits = intersect_triangle(ray_origin, ray_direction, p0, p1, p2, t_current, barycentric_current) &&
        t_current < max_ray_distance&&
        traversal.t > t_current;

    if (hits)
    {
        traversal.t = t_current;
        traversal.barycentric = barycentric_current;
        traversal.hit_index = index;
        max_ray_distance = traversal.t;
    }

    if (traversal.any_hit && hits) 
      return true;
    return false;
}

bool visit_object_aabb(vec3 ray_origin, vec3 ray_direction, uint i, inout float max_ray_distance, out bool hits)
{
    traversal.base_index = geometries[i].indices_base_index;
    traversal.base_vertex = geometries[i].points_base_index;
    vec3 ro = (geometries[i].inverse_transformation * vec4(ray_origin, 1)).xyz;
    vec3 rd = (((geometries[i].inverse_transformation) * vec4(ray_direction, 0)).xyz);
    traversal.t = max_ray_distance;
    
    bool current_hits = bvh_traverse(geometries[i].bvh_node_base_index, geometries[i].bvh_index_base_index, ro, rd, max_ray_distance);

    current_hits = current_hits && traversal.global_t > traversal.t;

    if (current_hits)
    {
        traversal.global_t = traversal.t;
        traversal.global_barycentric = traversal.barycentric;
        traversal.global_hit_index = traversal.hit_index;
        traversal.hit_geometry = i;
        max_ray_distance = traversal.global_t;
    }

    hits = current_hits;

    if (traversal.any_hit && hits) return true;
    return false;
}

bool any_hit(vec3 ray_origin, vec3 ray_direction, float max_distance)
{
    traversal_init();
    traversal.any_hit = true;
    traversal.t = max_distance;
    traversal.global_t = max_distance;
    bool hits = bvh_traverse_global(0, 0, ray_origin, ray_direction, max_distance);

    if (!hits)
    {
      for (int i = DONT_OPTIMIZE_ZERO; i < sdf_drawables.length(); ++i)
      {
        sdf_current = i;
        if (march_sdf(ray_origin, ray_direction, max_distance, true, sdf_marching_steps, sdf_marching_epsilon).hits)
          return true;
      }
    }
    return hits;
}

hit_t nearest_hit(vec3 ray_origin, vec3 ray_direction, float max_distance)
{
    hit_t hit;
    hit.hits_light = -1;

    traversal_init();
    traversal.any_hit = false;
    traversal.global_t = max_distance;
    hit.hits = bvh_traverse_global(0, 0, ray_origin, ray_direction, max_distance);
    hit.t = traversal.global_t;

    bool hit_marched = false;
    for (int i = DONT_OPTIMIZE_ZERO; i < sdf_drawables.length(); ++i)
    {
      sdf_current = i;
      hit_t h = march_sdf(ray_origin, ray_direction, hit.hits ? hit.t : max_distance, false, sdf_marching_steps, sdf_marching_epsilon);
      if (h.hits && h.t < hit.t) {
        hit = h;
        hit.hits_light = -1;
        hit_marched = true;
      }
    }

    if (hit_marched)
      return hit;

    vec2 hit_bary = traversal.global_barycentric;
    uint hit_triangle = traversal.global_hit_index;
    uint hit_geometry = traversal.hit_geometry;

    uint base_vertex = geometries[hit_geometry].points_base_index;
    uint base_index = geometries[hit_geometry].indices_base_index;

    vec3 p0 = points[base_vertex + indices[base_index + 3 * hit_triangle + 0]].xyz;
    vec3 p1 = points[base_vertex + indices[base_index + 3 * hit_triangle + 1]].xyz;
    vec3 p2 = points[base_vertex + indices[base_index + 3 * hit_triangle + 2]].xyz;
    hit.position = (geometries[hit_geometry].transformation * vec4(hit_bary.x * p1 + hit_bary.y * p2 + (1.0 - hit_bary.x - hit_bary.y) * p0, 1)).xyz;
    
    vec3 n0 = normals[base_vertex + indices[base_index + 3 * hit_triangle + 0]].xyz;
    vec3 n1 = normals[base_vertex + indices[base_index + 3 * hit_triangle + 1]].xyz;
    vec3 n2 = normals[base_vertex + indices[base_index + 3 * hit_triangle + 2]].xyz;
    mat3 normal_matrix = mat3(transpose(geometries[hit_geometry].inverse_transformation));
    vec3 normal = normalize(normal_matrix * (hit_bary.x * n1 + hit_bary.y * n2 + (1.0 - hit_bary.x - hit_bary.y) * n0));
    vec3 face_normal = normalize(normal_matrix * cross(normalize(p1 - p0), normalize(p2 - p0)));
    
    hit.normal = normal;

    hit.material_index = geometries[hit_geometry].material_index;
    
    vec2 u0 = uvs[base_vertex + indices[base_index + 3 * hit_triangle + 0]];
    vec2 u1 = uvs[base_vertex + indices[base_index + 3 * hit_triangle + 1]];
    vec2 u2 = uvs[base_vertex + indices[base_index + 3 * hit_triangle + 2]];
    hit.uv = hit_bary.x * u1 + hit_bary.y * u2 + (1.0 - hit_bary.x - hit_bary.y) * u0;

    return hit;
}