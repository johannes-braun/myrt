#version 430 core

layout(local_size_x = 8, local_size_y = 8) in;

#include "random.glsl"
#include "transform.glsl"
#include "ggx.glsl"

layout(binding = 0) uniform sampler2D positions;
layout(binding = 1) uniform sampler2D normals;
layout(binding = 1, rgba16f) uniform writeonly image2D output_image;

const float ssao_distance = 0.1;
const float ssao_fac = 0.2;

void main()
{
  uvec2 pt = gl_GlobalInvocationID.xy;
  uvec2 image_size = uvec2(textureSize(positions, 0));
  uint id = pt.y * image_size.x + pt.x;
  if(pt.x > image_size.x || pt.y > image_size.y)
  {
    return;
  }
  vec2 pixel = vec2(pt);
  
  float freeness = 0;
  int samplesxy = 1;
  int samplesd = 8;

  float test_distance = ssao_distance;

  vec3 position = 

  for(int i=0; i<samplesd; ++i)
  {
    for(int x = 0; x < samplesxy; ++x)
    {
      vec2 hs = 2 * random_next_2d() - 1;
      vec3 hemi = sample_hemisphere(hs);
      vec3 world = normalize(transform_local_to_world(hemi, normal));

      vec3 test_point = position + world * test_distance;

      vec4 hom = proj * view * vec4(test_point, 1);

      if(hom.w == 0)
      {
        freeness+=1;
        continue;
      }

      vec2 px = ((hom.xy / hom.w) + 1) / 2;
      px *= gbuffersize;
      px = clamp(px, vec2(0), gbuffersize - 1);

      vec4 other_norm = texelFetch(gbuffer, ivec3(px, 2), 0);

      if(other_norm.xyz == vec3(0))
      {
        freeness+=1;
        continue;
      }
        
      vec4 other_pos = texelFetch(gbuffer, ivec3(px, 0), 0);
      vec3 to_one = cam_pos - test_point;
      vec3 to_other = cam_pos - other_pos.xyz;

      float diff = length(to_other) - length(to_one);
      float s = sign(diff);
      diff = diff;

      if(diff > 0)
      {
        freeness += 1;
        continue;
      }

      freeness += float(diff < -ssao_fac);
    }
    test_distance /= 2;
  }
  freeness /= float(samplesxy) * samplesd;



  imageStore(output_image, ivec2(pt), color);
}