#version 460 core

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) uniform sampler2D input_image;
layout(binding = 1, rgba16f) uniform writeonly image2D output_image;
uniform float exponent = 2;
uniform float strength = 1;

#define SIGMA exponent
#define BSIGMA strength
#define MSIZE 10

float normpdf(in float x, in float sigma)
{
	return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;
}

float normpdf3(in vec3 v, in float sigma)
{
	return 0.39894*exp(-0.5*dot(v,v)/(sigma*sigma))/sigma;
}

void main() {
  uvec2 pt = gl_GlobalInvocationID.xy;
  uvec2 image_size = uvec2(textureSize(input_image, 0));
  uint id = pt.y * image_size.x + pt.x;
  if(pt.x > image_size.x || pt.y > image_size.y)
  {
    return;
  }
  vec2 pixel = vec2(pt);
  vec3 c = texelFetch(input_image, ivec2(pixel), 0).rgb;
		
	//declare stuff
	const int kSize = (MSIZE-1)/2;
	float kernel[MSIZE];
	vec3 final_colour = vec3(0.0);
	
	//create the 1-D kernel
	float Z = 0.0;
	for (int j = 0; j <= kSize; ++j)
	{
		kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);
	}
	
	vec3 cc;
	float factor;
	float bZ = 1.0/normpdf(0.0, BSIGMA);
	//read out the texels
	for (int i=-kSize; i <= kSize; ++i)
	{
		for (int j=-kSize; j <= kSize; ++j)
		{
			cc = clamp(texelFetch(input_image, clamp(ivec2(pixel) + ivec2(i, j), ivec2(0), ivec2(image_size) - 1), 0).rgb, 0.f, 1.f);
			factor = normpdf3(cc-c, BSIGMA)*bZ*kernel[kSize+j]*kernel[kSize+i];
			Z += factor;
			final_colour += factor*cc;
	
		}
	}
	
	imageStore(output_image, ivec2(pixel), vec4(final_colour/Z, 1.0));
}